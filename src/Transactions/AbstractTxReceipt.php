<?php
declare(strict_types=1);

namespace ForwardBlock\Protocol\Transactions;

use Comely\DataTypes\Buffer\Binary;
use ForwardBlock\Protocol\AbstractProtocolChain;
use ForwardBlock\Protocol\Exception\TxEncodeException;
use ForwardBlock\Protocol\Exception\TxReceiptDecodeException;
use ForwardBlock\Protocol\Math\UInts;
use ForwardBlock\Protocol\ProtocolConstants;
use ForwardBlock\Protocol\Transactions\Receipts\LedgerEntries;
use ForwardBlock\Protocol\Transactions\Receipts\LedgerEntry;
use ForwardBlock\Protocol\Transactions\Receipts\LedgerFlag;

/**
 * Class AbstractTxReceipt
 * @package ForwardBlock\Protocol\Transactions
 */
abstract class AbstractTxReceipt
{
    /** @var AbstractProtocolChain */
    protected AbstractProtocolChain $p;
    /** @var AbstractPreparedTx|null */
    protected ?AbstractPreparedTx $tx = null;
    /** @var int */
    protected int $blockHeightContext;

    /** @var int|null */
    protected ?int $status = null;
    /** @var Binary */
    protected Binary $data;
    /** @var LedgerEntries */
    protected LedgerEntries $ledgerEntries;

    /** @var int */
    protected int $totalIn;
    /** @var int */
    protected int $totalOut;
    /** @var int */
    protected int $totalFee;

    /**
     * @param AbstractProtocolChain $p
     * @param AbstractPreparedTx|null $tx
     * @param int $blockHeightContext
     * @param Binary $encoded
     * @return static
     * @throws TxReceiptDecodeException
     */
    public static function Decode(AbstractProtocolChain $p, ?AbstractPreparedTx $tx, int $blockHeightContext, Binary $encoded): self
    {
        $receipt = new static($p, $tx, $blockHeightContext);

        // Purge all raw receipts generated by callback (generateLedgerEntries())
        $receipt->ledgerEntries->purge();

        $read = $encoded->read();
        $read->throwUnderflowEx();

        // Step 1
        $txId = $read->first(32);
        if ($tx && $txId !== $tx->hash()->raw()) {
            throw new TxReceiptDecodeException(sprintf(
                'Receipt for tx "0x%s" does not match transaction hash "0x%s"', bin2hex($txId), bin2hex($tx->hash()->raw())
            ));
        }

        // Step 2
        $status = UInts::Decode_UInt2LE($read->next(2));
        $receipt->setStatus($status);

        // Step 3
        $dataLen = UInts::Decode_UInt1LE($read->next(1));
        if ($dataLen > 0) { // Step 3.1
            $receipt->data()->append($read->next($dataLen));
        }

        // Step 4,5,6
        $totalIn = UInts::Decode_UInt8LE($read->next(8));
        $totalOut = UInts::Decode_UInt8LE($read->next(8));
        $totalFee = UInts::Decode_UInt8LE($read->next(8));

        // Step 7
        $leBatches = UInts::Decode_UInt1LE($read->next(1));
        if ($leBatches > 0) {
            for ($lB = 0; $lB < $leBatches; $lB++) {
                $leC = UInts::Decode_UInt1LE($read->next(1));
                $leBatch = [];
                if ($leC < 0 || $leC > ProtocolConstants::MAX_LEDGER_ENTRIES) {
                    throw new TxReceiptDecodeException(
                        sprintf('Receipt batch contains %d ledger entries, allowed are 1 to %d', $leC, ProtocolConstants::MAX_LEDGER_ENTRIES)
                    );
                }

                for ($leN = 0; $leN < $leC; $leN++) {
                    $hash160 = $read->next(20); // Account Hash160 bytes
                    $flag = $p->txFlags()->ledgerFlags()->get(UInts::Decode_UInt2LE($read->next(2)));
                    $amount = UInts::Decode_UInt8LE($read->next(8));
                    $asset = trim($read->next(8));
                    if (!$asset) { // Native token?
                        $asset = null;
                    }

                    $status = $read->next(1);
                    if (!in_array($status, ["\0", "\1"])) {
                        throw new TxReceiptDecodeException(sprintf('Invalid ledger entry # %d status byte', $leN + 1));
                    }

                    $decodedLE = new LedgerEntry($p, $receipt, $flag, $hash160, $amount, $asset);
                    if ($status === "\1") {
                        $decodedLE->markApplicable();
                    }

                    $leBatch[] = $decodedLE;
                }

                $receipt->registerLedgerEntriesBatch(...$leBatch);
            }
        }

        $receipt->calculateLedgerEntries(true);

        // Validations
        if ($receipt->totalIn() !== $totalIn) {
            throw new TxReceiptDecodeException(
                sprintf('Receipt total in "%d" does not match actual total in "%d"', $receipt->totalIn(), $totalIn)
            );
        }

        if ($receipt->totalOut() !== $totalOut) {
            throw new TxReceiptDecodeException(
                sprintf('Receipt total out "%d" does not match actual total out "%d"', $receipt->totalOut(), $totalOut)
            );
        }

        if ($receipt->totalFee() !== $totalFee) {
            throw new TxReceiptDecodeException(
                sprintf('Receipt total fee "%d" does not match actual total fee "%d"', $receipt->totalFee(), $totalFee)
            );
        }

        // Return receipt
        return $receipt;
    }

    /**
     * AbstractTxReceipt constructor.
     * @param AbstractProtocolChain $p
     * @param AbstractPreparedTx|null $tx
     * @param int $blockHeightContext
     */
    public function __construct(AbstractProtocolChain $p, ?AbstractPreparedTx $tx, int $blockHeightContext)
    {
        $this->p = $p;
        $this->data = new Binary();
        $this->ledgerEntries = new LedgerEntries();
        $this->blockHeightContext = $blockHeightContext;
        $this->tx = $tx;

        // Generate default ledger entries; i.e. transaction's base fee
        $this->defaultLedgerEntries();

        // Generate ledger entries here; Based on Transaction's type/flag
        $this->generateLedgerEntries();

        // Make calculations
        $this->calculateLedgerEntries(false);
    }

    /**
     * This method MUST BE used to generate default fee ledger entries based on transaction's fee amount
     * @return void
     */
    abstract protected function defaultLedgerEntries(): void;

    /**
     * @param bool $applicableOnly
     */
    public function calculateLedgerEntries(bool $applicableOnly = false): void
    {
        $this->totalIn = 0;
        $this->totalOut = 0;
        $this->totalFee = 0;

        $batches = $this->ledgerEntries->batches();
        if ($batches) {
            foreach ($batches as $batch) {
                /** @var LedgerEntry $ledgerEntry */
                foreach ($batch as $ledgerEntry) {
                    if ($ledgerEntry->asset()) {
                        continue; // Ignore LEs with an asset
                    }

                    if ($applicableOnly && !$ledgerEntry->isApplicable()) {
                        continue; // Ignore non-applicable ones
                    }

                    if ($ledgerEntry->flag()->isCredit()) {
                        $this->totalOut = $ledgerEntry->amount();
                    } else {
                        $this->totalIn = $ledgerEntry->amount();
                    }
                }
            }
        }

        $this->calculateTotalFee();
    }

    /**
     * @return void
     */
    protected function calculateTotalFee(): void
    {
        $this->totalFee = $this->totalIn - $this->totalOut;
    }

    /**
     * @return array
     */
    public function __debugInfo(): array
    {
        return $this->dump();
    }

    /**
     * @return array
     */
    public function dump(): array
    {
        return [
            "status" => $this->status,
            "data" => $this->data->raw(),
            "ledgerEntries" => $this->ledgerEntries->dump(),
            "totalIn" => $this->totalIn,
            "totalOut" => $this->totalOut,
            "totalFee" => $this->totalFee,
        ];
    }

    /**
     * This method is called on construct of receipt to generate RAW ledger entries
     */
    abstract protected function generateLedgerEntries(): void;

    /**
     * This method is called when transaction receipt is being finalised
     */
    abstract protected function finalizeCallback(): void;

    /**
     * This method is called when transaction is being applied
     */
    abstract public function applyCallback(): void;

    /**
     * This method is called when transaction is being undone
     */
    abstract public function undoCallback(): void;

    /**
     * @return bool
     */
    public function isFinalised(): bool
    {
        return is_int($this->status) && $this->status >= 0;
    }

    /**
     * @return AbstractPreparedTx
     */
    public function getTx(): AbstractPreparedTx
    {
        if (!$this->tx) {
            throw new \UnexpectedValueException('Tx instance was never stored');
        }

        return $this->tx;
    }

    /**
     * @return Binary
     */
    public function data(): Binary
    {
        return $this->data;
    }

    /**
     * @param int $code
     * @return $this
     */
    public function setStatus(int $code): self
    {
        $this->status = $code;
        return $this;
    }

    /**
     * @return int
     */
    public function totalIn(): int
    {
        return $this->totalIn;
    }

    /**
     * @return int
     */
    public function totalOut(): int
    {
        return $this->totalOut;
    }

    /**
     * @return int
     */
    public function totalFee(): int
    {
        return $this->totalFee;
    }

    /**
     * @return int|null
     */
    public function status(): ?int
    {
        return $this->status;
    }

    /**
     * @return LedgerEntries
     */
    public function ledgerEntries(): LedgerEntries
    {
        return $this->ledgerEntries;
    }

    /**
     * @return Binary
     */
    public function ledgerEntriesHash(): Binary
    {
        $serBatch = $this->ledgerEntries->serializedBatches();
        return $this->p->hash256(new Binary($this->getTx()->hash()->raw() . $serBatch))->readOnly(true);
    }

    /**
     * @return Binary
     * @throws TxEncodeException
     */
    public function getReceiptHash(): Binary
    {
        $raw = $this->halfSerialize()->append($this->ledgerEntriesHash());
        return $this->p->hash256($raw);
    }

    /**
     * @return Binary
     * @throws TxEncodeException
     */
    public function serialize(): Binary
    {
        $ser = $this->halfSerialize();
        $ser->append($this->ledgerEntries->serializedBatches());
        return $ser->readOnly(true);
    }

    /**
     * @return Binary
     * @throws TxEncodeException
     */
    private function halfSerialize(): Binary
    {
        if (!is_int($this->status)) {
            throw new TxEncodeException('TxReceipt status not set');
        }

        $ser = new Binary();
        $ser->append($this->getTx()->hash()->raw());
        $ser->append(UInts::Encode_UInt2LE($this->status));

        if ($this->data->sizeInBytes > 0xff) {
            throw new TxEncodeException('TxReceipt data cannot exceed 255 bytes');
        }

        $ser->append(UInts::Encode_UInt1LE($this->data->sizeInBytes));
        $ser->append($this->data);

        $ser->append(UInts::Encode_UInt8LE($this->totalIn));
        $ser->append(UInts::Encode_UInt8LE($this->totalOut));
        $ser->append(UInts::Encode_UInt8LE($this->totalFee));
        return $ser;
    }

    /**
     * @param LedgerFlag $lF
     * @param string $hash160
     * @param int $amount
     * @param string|null $assetId
     * @return LedgerEntry
     */
    public function createLedgerEntry(LedgerFlag $lF, string $hash160, int $amount, ?string $assetId = null): LedgerEntry
    {
        return new LedgerEntry($this->p, $this, $lF, $hash160, $amount, $assetId);
    }

    /**
     * @param LedgerEntry ...$entries
     */
    public function registerLedgerEntriesBatch(LedgerEntry ...$entries): void
    {
        $this->ledgerEntries->addBatch(...$entries);
    }
}
